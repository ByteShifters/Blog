---
title: "Domain Generation Algorithms and Automatic Domain Registration in C2"
tags: ['System Security', 'Low level', 'Rootkits', 'Malware', 'C2']
date: 2024-10-04
author: 'Ren'
authorlink: 'https://about.0x0060.dev/'
toc: true
---

# Domain Generation Algorithms and Automatic Domain Registration

Domain Generation Algorithms (DGAs) are critical tools used in various applications, including both legitimate and malicious domains. This blog post discusses how DGAs function and demonstrates how to automatically register the generated domains using the Namecheap API.

## What is a Domain Generation Algorithm (DGA)?

A Domain Generation Algorithm (DGA) is a technique used primarily in malware to generate domain names that are used for command and control (C2) operations. These algorithms can produce a large number of domain names dynamically, making it difficult for security systems to block them.

### How DGAs Work

1. **Input Parameters**: DGAs typically take in various parameters such as a seed, date, and suffix.
2. **Random Generation**: Using these parameters, the algorithm generates pseudo-random domain names.
3. **Domain Construction**: The final domain name is constructed by combining components derived from hashing and randomization.

## Implementation of DGA in Go

Below is an implementation of a DGA in Go that generates domain names based on a given base domain, seed, and suffix.

### Code for Domain Generation

```
package main

import (
	"dga-project/pkg/dga"
	"fmt"
	"os"
	"time"
)

func main() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: go run ./cmd/dga/ <domain.com> <seed> <suffix>")
		os.Exit(1)
	}

	baseDomain := os.Args[1]
	seed := os.Args[2]
	suffix := os.Args[3]

	currentDate := time.Now()

	domains := dga.GenerateDomains(baseDomain, seed, suffix, currentDate, 20)
	for _, domain := range domains {
		fmt.Println("Generated Domain:", domain)
	}
}
```

### Domain Generation Logic

The domain generation logic can be found in the `dga` package. Here's the code:

```
package dga

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"math/rand"
	"time"
)

func GenerateDomains(baseDomain string, seed string, suffix string, date time.Time, count int) []string {
	var domains []string

	dateString := date.Format("20060102")

	rand.Seed(time.Now().UnixNano())

	for i := 0; i < count; i++ {
		randomComponent := rand.Intn(1000000)
		hashInput := fmt.Sprintf("%s%s%d%d", seed, dateString, i, randomComponent)
		hashedValue := sha256.Sum256([]byte(hashInput))
		hashString := hex.EncodeToString(hashedValue[:])

		prefix := hashString[0:6]
		middle := hashString[6:12]

		domainName := fmt.Sprintf("%s.%s.%s.%s", prefix, middle, suffix, baseDomain)
		domains = append(domains, domainName)
	}

	return domains
}
```

## Automatic Domain Registration with Namecheap API

To register the generated domains automatically, we can use the Namecheap API. Below is the implementation for domain registration.

### Code for Automatic Domain Registration

This code is placed in the `autoregister` package:

```
package autoregister

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
)

const (
	apiUrl   = "https://api.namecheap.com/v1/domains/create"
	apiUser  = "YOUR_API_USER"
	apiKey   = "YOUR_API_KEY"
	userName = "YOUR_USER_NAME"
	clientIp = "YOUR_CLIENT_IP"
)

type DomainRegistrationRequest struct {
	ApiUser    string `json:"ApiUser"`
	ApiKey     string `json:"ApiKey"`
	UserName   string `json:"UserName"`
	ClientIp   string `json:"ClientIp"`
	DomainName string `json:"DomainName"`
	Years      int    `json:"Years"`
	AddOns     string `json:"AddOns"`
}

type DomainRegistrationResponse struct {
	Command string `json:"Command"`
	Status  string `json:"Status"`
}

func RegisterDomain(domain string, years int) {
	request := DomainRegistrationRequest{
		ApiUser:    apiUser,
		ApiKey:     apiKey,
		UserName:   userName,
		ClientIp:   clientIp,
		DomainName: domain,
		Years:      years,
		AddOns:     "", // Optional, e.g., "WhoisGuard"
	}

	jsonData, err := json.Marshal(request)
	if err != nil {
		fmt.Println("Error marshalling request:", err)
		return
	}

	resp, err := http.Post(apiUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		fmt.Println("Error sending request:", err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Println("Error: Received status code", resp.StatusCode)
		return
	}

	body, _ := ioutil.ReadAll(resp.Body)

	var response DomainRegistrationResponse
	if err := json.Unmarshal(body, &response); err != nil {
		fmt.Println("Error unmarshalling response:", err)
		return
	}

	fmt.Printf("Domain Registration Status for %s: %s\n", domain, response.Status)
}
```

### Integrating Domain Generation and Registration

Finally, integrate both functionalities in the `cmd/dga/main.go` file:

```
package main

import (
	"dga-project/pkg/autoregister"
	"dga-project/pkg/dga"
	"fmt"
	"os"
	"time"
)

func main() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: go run ./cmd/dga/ <domain.com> <seed> <suffix>")
		os.Exit(1)
	}

	baseDomain := os.Args[1]
	seed := os.Args[2]
	suffix := os.Args[3]

	currentDate := time.Now()

	domains := dga.GenerateDomains(baseDomain, seed, suffix, currentDate, 20)
	for _, domain := range domains {
		fmt.Println("Generated Domain:", domain)
		autoregister.RegisterDomain(domain, 1)
	}
}
```

## Summary

This blog post illustrated how to implement a Domain Generation Algorithm (DGA) in Go and how to automate the registration of the generated domains using the Namecheap API. This dual approach can be applied in various domains, from cybersecurity research to legitimate business operations.

### Important Considerations

- **API Credentials**: Ensure you replace the placeholders for `apiUser`, `apiKey`, `userName`, and `clientIp` with your actual Namecheap account details.
- **Costs**: Be mindful of the costs associated with domain registration.
- **Legal Compliance**: Use this technology responsibly and ensure compliance with all relevant laws and regulations.

Feel free to reach out if you have any questions or need further clarification on any of the topics discussed!
